"""
This module contains features related to outputs generated by a model.

The main responsibilities are data structures for holding such outputs, and code to translate outputs into readable
strings.
"""

from typing import Optional, Sequence

from xnmt.vocab import Vocab
from xnmt.persistence import Serializable, serializable_init

class Output(object):
  """
  A template class to represent output generated by a model.
  """
  def __init__(self, actions: Optional[Sequence[int]], score: float) -> None:
    """ Initialize an output with actions.

    Args:
      actions: list of output actions chosen by the model
      score: score given by the model to this output
    """
    self.actions = actions
    self.score = score

  def readable_actions(self) -> Sequence[str]:
    """
    Get a readable version of the output actions.

    This may include looking up word ids in a vocabulary and omitting special tokens such as <s> and </s>

    Returns:
      list containing readable version for each action
    """
    raise NotImplementedError('must be implemented by subclasses')

  def __str__(self):
    return " ".join(self.readable_actions())



class ScalarOutput(Output):
  """
  Output of classifier models that generate only a single action.

  Args:
    actions: list of length 1
    score: score given by the model to this output
    vocab: optional vocabulary corresponding to the actions
  """
  def __init__(self, actions: Sequence[int], score: float, vocab: Optional[Vocab] = None) -> None:
    super().__init__(actions=actions, score=score)
    if len(self.actions) > 1: raise ValueError(f"ScalarOutput must have exactly one action, get: {len(self.actions)}")
    self.vocab = vocab

  def readable_actions(self) -> Sequence[str]:
    """
    Get a readable version of the output action by performing on optional vocabulary lookup.

    Returns:
      list containing a single item
    """
    return [self.vocab[self.actions[0]]] if self.vocab else [str(self.actions[0])]


class TextOutput(Output):
  """
  Output of a sequence of actions corresponding to text.

  Args:
    actions: list of length 1
    score: score given by the model to this output
    vocab: optional vocabulary corresponding to the actions
  """
  def __init__(self, actions: Sequence[int], score: float, vocab: Optional[Vocab] = None):
    super().__init__(actions=actions, score=score)
    self.vocab = vocab
    self.filtered_tokens = {Vocab.SS, Vocab.ES}

  def readable_actions(self):
    """
    Get a readable version of the output actions by performing an optional vocabulary lookup and omitting <s> and </s>.

    Returns:
      list containing readable version for each action
    """
    ret = []
    for action in self.actions:
      if action not in self.filtered_tokens:
        ret.append(self.vocab[action] if self.vocab else str(action))
    return ret

class OutputProcessor(object):
  # TODO: this should be refactored so that multiple processors can be chained
  def process_output(self, output: Output) -> str:
    """
    Produce a string-representation of an Output object.

    Args:
      output: object holding output actions

    Returns:
      string representation
    """
    raise NotImplementedError("must be implemented by subclasses")

  @staticmethod
  def get_output_processor(spec):
    if spec == "none":
      return PlainTextOutputProcessor()
    elif spec == "join-char":
      return JoinCharTextOutputProcessor()
    elif spec == "join-bpe":
      return JoinBPETextOutputProcessor()
    elif spec == "join-piece":
      return JoinPieceTextOutputProcessor()
    else:
      return spec

class PlainTextOutputProcessor(OutputProcessor, Serializable):
  """
  Handles the typical case of writing plain text, with one sentence per line.
  """
  yaml_tag = "!PlainTextOutputProcessor"
  def process_output(self, output):
    return " ".join(output.readable_actions())

class JoinCharTextOutputProcessor(PlainTextOutputProcessor, Serializable):
  """
  Assumes a single-character vocabulary and joins them to form words.

  Per default, double underscores '__' are treated as word separating tokens.
  """
  yaml_tag = "!JoinCharTextOutputProcessor"
  @serializable_init
  def __init__(self, space_token="__"):
    self.space_token = space_token

  def process_output(self, output):
    word_list = output.readable_actions()
    return "".join(" " if s==self.space_token else s for s in  word_list)

class JoinBPETextOutputProcessor(PlainTextOutputProcessor, Serializable):
  """
  Assumes a bpe-based vocabulary and outputs the merged words.

  Per default, the '@' postfix indicates subwords that should be merged
  """
  yaml_tag = "!JoinBPETextOutputProcessor"
  @serializable_init
  def __init__(self, merge_indicator="@@"):
    self.merge_indicator_with_space = merge_indicator + " "

  def process_output(self, output):
    word_list = output.readable_actions()
    return " ".join(word_list).replace(self.merge_indicator_with_space, "")

class JoinPieceTextOutputProcessor(PlainTextOutputProcessor, Serializable):
  """
  Assumes a sentence-piece vocabulary and joins them to form words.

  Space_token could be the starting character of a piece per default, the u'\u2581' indicates spaces
  """
  yaml_tag = "!JoinPieceTextOutputProcessor"
  @serializable_init
  def __init__(self, space_token="\u2581"):
    self.space_token = space_token

  def process_output(self, output):
    word_list = output.readable_actions()
    return "".join(word_list).replace(self.space_token, " ").strip()
